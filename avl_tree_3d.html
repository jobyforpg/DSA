<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D AVL Tree Rotation Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a2e; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none; /* Let clicks pass through to 3D canvas */
            z-index: 10;
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            pointer-events: auto;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            width: 320px;
            transition: height 0.3s ease;
        }

        input[type="number"] {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px;
            border-radius: 6px;
            width: 100%;
            margin-bottom: 10px;
            outline: none;
        }

        button {
            background: linear-gradient(45deg, #4ecdc4, #556270);
            border: none;
            padding: 10px;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.1s, opacity 0.2s;
        }

        button:active { transform: scale(0.98); }
        button:hover { opacity: 0.9; }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        
        .btn-group {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .btn-icon { flex: 1; display: flex; align-items: center; justify-content: center; gap: 5px; }
        .btn-reset { background: linear-gradient(45deg, #ff6b6b, #c0392b); width: 100%; margin-top: 5px; }

        /* Toggle Switch */
        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            font-size: 0.9rem;
            color: #a8b2d1;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: #4ecdc4; }
        input:checked + .slider:before { transform: translateX(20px); }

        #status-log {
            margin-top: 15px;
            font-size: 0.9rem;
            color: #a8b2d1;
            min-height: 20px;
        }

        .highlight { color: #4ecdc4; font-weight: bold; }

        /* Guide Styling */
        details > summary {
            list-style: none;
            cursor: pointer;
            transition: color 0.2s;
        }
        details > summary::-webkit-details-marker { display: none; }
        details[open] summary ~ * { animation: sweep .3s ease-in-out; }
        @keyframes sweep {
            0%    {opacity: 0; transform: translateY(-10px)}
            100%  {opacity: 1; transform: translateY(0)}
        }

        #controls-hint {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: rgba(255,255,255,0.5);
            text-align: right;
            font-size: 0.8rem;
            pointer-events: none;
        }
        
        /* Legend for BF */
        .legend {
            display: inline-block;
            width: 10px;
            height: 10px;
            background-color: #f1c40f;
            border-radius: 50%;
            margin-right: 5px;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="panel">
            <h2 class="text-xl font-bold mb-4 border-b border-gray-600 pb-2">AVL Tree Engine</h2>
            
            <!-- Input -->
            <label class="text-xs uppercase tracking-wide text-gray-400">Add Node Value</label>
            <div class="flex gap-2 mt-1 mb-3">
                <input type="number" id="nodeValue" placeholder="e.g. 42" onkeypress="handleInput(event)">
            </div>
            <button onclick="addNode()" class="w-full mb-4">Insert Node</button>

            <!-- Action Controls -->
            <div class="toggle-container">
                <span>üê¢ Slow Motion</span>
                <label class="switch">
                    <input type="checkbox" id="slowMoToggle" onchange="toggleSlowMo()">
                    <span class="slider"></span>
                </label>
            </div>

            <div class="btn-group">
                <button class="btn-icon" id="btn-undo" onclick="undo()" disabled>
                    ‚Ü© Undo
                </button>
                <button class="btn-icon" id="btn-redo" onclick="redo()" disabled>
                    Redo ‚Ü™
                </button>
            </div>

            <button class="btn-reset" onclick="resetTree()">Reset All</button>

            <div id="status-log">Ready to build...</div>

            <!-- Guide Section -->
            <details class="mt-6 border-t border-gray-600 pt-3 text-sm text-gray-300">
                <summary class="font-bold text-white hover:text-teal-400 flex justify-between items-center select-none">
                    <span>üìò Guide & Rules</span>
                    <span class="text-xs text-gray-500">‚ñº</span>
                </summary>
                <div class="mt-3 space-y-3 text-xs leading-relaxed">
                    <div>
                        <strong class="text-teal-400 block mb-1">üéÆ Controls</strong>
                        <ul class="list-disc pl-4 text-gray-400">
                            <li>Input Number + Enter to Insert.</li>
                            <li>Left Click + Drag to Rotate.</li>
                            <li>Right Click + Drag to Pan.</li>
                            <li>Scroll to Zoom.</li>
                        </ul>
                    </div>
                    <div>
                        <strong class="text-teal-400 block mb-1">‚öñÔ∏è AVL Rules</strong>
                        <p>The tree self-balances to keep search efficient.</p>
                        <ul class="list-disc pl-4 mt-1 text-gray-400">
                            <li><strong>Balance Factor <span class="legend"></span>:</strong> Height(Left) - Height(Right).</li>
                            <li>Displayed as small yellow number.</li>
                            <li>If Factor is > 1 or < -1, it rotates.</li>
                        </ul>
                    </div>
                </div>
            </details>
        </div>
    </div>

    <div id="controls-hint">
        Left Click: Rotate &bull; Right Click: Pan &bull; Scroll: Zoom
    </div>

    <div id="canvas-container"></div>

    <!-- Three.js Imports -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let treeRoot = null;
        let nodes = []; // Array to track all logical node objects for updates
        let edges = []; // Array to track line connections
        
        // State Management
        let currentValues = []; // List of values in the tree
        let historyStack = [];  // Array of arrays (past states)
        let futureStack = [];   // Array of arrays (redo states)
        const meshCache = new Map(); // Value -> THREE.Group (Preserve meshes across rebuilds)

        // Config
        const LAYER_HEIGHT = 2.5;
        const ANIMATION_SPEED_FAST = 0.08;
        const ANIMATION_SPEED_SLOW = 0.01; 
        let currentAnimationSpeed = ANIMATION_SPEED_FAST;

        // --- UI Helpers ---
        const logEl = document.getElementById('status-log');
        function log(msg, type="neutral") {
            logEl.innerHTML = msg;
            if(type === "action") logEl.style.color = "#4ecdc4";
            else if(type === "alert") logEl.style.color = "#ff6b6b";
            else logEl.style.color = "#a8b2d1";
        }

        window.toggleSlowMo = function() {
            const cb = document.getElementById('slowMoToggle');
            currentAnimationSpeed = cb.checked ? ANIMATION_SPEED_SLOW : ANIMATION_SPEED_FAST;
            log(cb.checked ? "Slow Motion: ON" : "Slow Motion: OFF");
        }

        function updateButtons() {
            document.getElementById('btn-undo').disabled = historyStack.length === 0;
            document.getElementById('btn-redo').disabled = futureStack.length === 0;
        }

        // --- 3D Setup ---
        function init() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.fog = new THREE.Fog(0x111111, 20, 100);

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 25);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 2);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            const spotLight = new THREE.SpotLight(0x4ecdc4, 50);
            spotLight.position.set(0, 20, 0);
            spotLight.angle = Math.PI / 6;
            spotLight.penumbra = 1;
            scene.add(spotLight);

            // Ground Grid
            const gridHelper = new THREE.GridHelper(100, 100, 0x333333, 0x222222);
            scene.add(gridHelper);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Window Resize
            window.addEventListener('resize', onWindowResize);

            // Start Loop
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Texture Generation ---
        
        // Helper to create labels
        function createLabelTexture(text, color = "#ffffff", fontSize = 250, isBold = true) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Draw Text with Outline
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            const weight = isBold ? "bold" : "";
            ctx.font = `${weight} ${fontSize}px Arial`;
            
            // Outline (Stroke)
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 15;
            ctx.strokeText(text, 256, 256);

            // Fill
            ctx.fillStyle = color;
            ctx.fillText(text, 256, 256);
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // --- AVL Tree Logic & Node Class ---

        class TreeNode {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.height = 1;
                this.currentBF = 0; // Track balance factor for display
                
                // 3D Properties
                this.targetPosition = new THREE.Vector3(0, 10, 0); // Default Spawn

                // --- Mesh Caching Logic ---
                if (meshCache.has(value)) {
                    this.mesh = meshCache.get(value);
                    if (!this.mesh.parent) scene.add(this.mesh);
                    // Re-bind sprite references
                    this.sprite = this.mesh.children.find(c => c.userData.type === 'value');
                    this.bfSprite = this.mesh.children.find(c => c.userData.type === 'bf');
                } else {
                    this.mesh = this.createMesh(value);
                    meshCache.set(value, this.mesh);
                    scene.add(this.mesh);
                    // Bind sprite references
                    this.sprite = this.mesh.children.find(c => c.userData.type === 'value');
                    this.bfSprite = this.mesh.children.find(c => c.userData.type === 'bf');
                }
                
                nodes.push(this);
            }

            createMesh(value) {
                const group = new THREE.Group();

                // Sphere
                const geometry = new THREE.SphereGeometry(0.8, 32, 32);
                const material = new THREE.MeshPhysicalMaterial({
                    color: 0x3498db,
                    metalness: 0.3,
                    roughness: 0.4,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.1
                });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.castShadow = true;
                sphere.receiveShadow = true;
                group.add(sphere);

                // 1. Node Value Sprite (White, Large)
                const valMap = createLabelTexture(value, "#ffffff", 250);
                const valMat = new THREE.SpriteMaterial({ map: valMap, transparent: true });
                const valSprite = new THREE.Sprite(valMat);
                valSprite.scale.set(1.5, 1.5, 1);
                valSprite.userData = { type: 'value' }; // Tag for identification
                group.add(valSprite);

                // 2. Balance Factor Sprite (Yellow, Smaller)
                // Initial "0" texture
                const bfMap = createLabelTexture("0", "#f1c40f", 200); 
                const bfMat = new THREE.SpriteMaterial({ map: bfMap, transparent: true });
                const bfSprite = new THREE.Sprite(bfMat);
                bfSprite.scale.set(0.8, 0.8, 1);
                bfSprite.userData = { type: 'bf' }; // Tag for identification
                group.add(bfSprite);

                // Start position (animation spawn)
                group.position.set(0, 5, 0); 

                return group;
            }

            updateBFVisual(bf) {
                // Only update texture if changed to save performance
                if (this.currentBF !== bf) {
                    this.currentBF = bf;
                    // Dispose old texture if needed, or just overwrite map
                    if (this.bfSprite.material.map) this.bfSprite.material.map.dispose();
                    
                    // Color coding: Green for 0, Yellow for 1/-1, Red for 2/-2 (imbalance)
                    let color = "#f1c40f"; // Default Yellow
                    if (bf === 0) color = "#2ecc71"; // Green
                    if (Math.abs(bf) >= 2) color = "#e74c3c"; // Red
                    
                    this.bfSprite.material.map = createLabelTexture(bf, color, 200);
                }
            }
        }

        // Helper: Get Height
        function height(N) {
            if (N === null) return 0;
            return N.height;
        }

        // Helper: Get Balance Factor
        function getBalance(N) {
            if (N === null) return 0;
            return height(N.left) - height(N.right);
        }

        // Right Rotation (LL Case)
        function rightRotate(y) {
            let x = y.left;
            let T2 = x.right;

            // Perform rotation
            x.right = y;
            y.left = T2;

            // Update heights
            y.height = Math.max(height(y.left), height(y.right)) + 1;
            x.height = Math.max(height(x.left), height(x.right)) + 1;

            return x; // New root
        }

        // Left Rotation (RR Case)
        function leftRotate(x) {
            let y = x.right;
            let T2 = y.left;

            // Perform rotation
            y.left = x;
            x.right = T2;

            // Update heights
            x.height = Math.max(height(x.left), height(x.right)) + 1;
            y.height = Math.max(height(y.left), height(y.right)) + 1;

            return y; // New root
        }

        // Insert Function
        function insert(node, value) {
            if (node === null) return new TreeNode(value);

            if (value < node.value) node.left = insert(node.left, value);
            else if (value > node.value) node.right = insert(node.right, value);
            else return node;

            node.height = 1 + Math.max(height(node.left), height(node.right));
            let balance = getBalance(node);

            // Rotations
            if (balance > 1 && value < node.left.value) return rightRotate(node);
            if (balance < -1 && value > node.right.value) return leftRotate(node);
            if (balance > 1 && value > node.left.value) {
                node.left = leftRotate(node.left);
                return rightRotate(node);
            }
            if (balance < -1 && value < node.right.value) {
                node.right = rightRotate(node.right);
                return leftRotate(node);
            }

            return node;
        }

        // --- Tree Update & Layout ---

        // 1. Recalculate Positions
        function updateTreeLayout(node, x, y, z, levelWidth) {
            if (node === null) return;

            node.targetPosition.set(x, y, z);
            
            const offset = levelWidth / 2;
            updateTreeLayout(node.left, x - offset, y - LAYER_HEIGHT, z, offset);
            updateTreeLayout(node.right, x + offset, y - LAYER_HEIGHT, z, offset);
        }

        // 2. Recalculate Balance Factors Visuals
        function updateBalanceVisuals(node) {
            if (node === null) return;
            
            const bf = getBalance(node);
            node.updateBFVisual(bf);
            
            updateBalanceVisuals(node.left);
            updateBalanceVisuals(node.right);
        }

        function refreshTree() {
            // Clear old edges
            edges.forEach(line => scene.remove(line));
            edges = [];

            if (treeRoot) {
                // --- Dynamic Layout Calculation ---
                const totalLevels = treeRoot.height; // 1-based height
                
                // 1. Height Calculation: Keep bottom nodes above y=0
                // Lowest level y = rootY - (totalLevels - 1) * LAYER_HEIGHT
                // We want Lowest Level Y >= 2.0
                const startY = 2.0 + (totalLevels - 1) * LAYER_HEIGHT;

                // 2. Width Calculation: Prevent overlap at bottom
                // Min distance between nodes = 2.2 units (approx 2x sphere radius + margin)
                // Root level spread must be enough so that leaf level spread is >= 2.2
                // spread(level) = initialSpread / (2^level)
                // We need spread(totalLevels-1) >= 2.2
                const minSpread = 2.5; 
                // Only start widening significantly if tree is deep (height > 2)
                const initialWidth = minSpread * Math.pow(2, Math.max(totalLevels - 2, 1));

                // Start layout calculation
                updateTreeLayout(treeRoot, 0, startY, 0, initialWidth);
                createEdges(treeRoot);
                
                // Update BF Labels
                updateBalanceVisuals(treeRoot);
            }
            
            pruneOrphans();
        }
        
        function pruneOrphans() {
            const activeValues = new Set(nodes.map(n => n.value));
            for (const [val, mesh] of meshCache) {
                if (!activeValues.has(val)) {
                    scene.remove(mesh);
                    meshCache.delete(val);
                }
            }
        }

        function createEdges(node) {
            if (node === null) return;

            if (node.left) {
                const line = createLine(node.mesh.position, node.left.mesh.position);
                line.userData = { from: node, to: node.left };
                scene.add(line);
                edges.push(line);
                createEdges(node.left);
            }

            if (node.right) {
                const line = createLine(node.mesh.position, node.right.mesh.position);
                line.userData = { from: node, to: node.right };
                scene.add(line);
                edges.push(line);
                createEdges(node.right);
            }
        }

        function createLine(p1, p2) {
            const geometry = new THREE.BufferGeometry().setFromPoints([p1, p2]);
            const material = new THREE.LineBasicMaterial({ 
                color: 0xffffff, 
                opacity: 0.3, 
                transparent: true, 
                linewidth: 2 
            });
            return new THREE.Line(geometry, material);
        }


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // 1. Move Nodes
            nodes.forEach(node => {
                node.mesh.position.lerp(node.targetPosition, currentAnimationSpeed);

                const nodePos = node.mesh.position;
                const camPos = camera.position;

                // Calculate base direction towards camera (normalized)
                const dir = new THREE.Vector3().subVectors(camPos, nodePos).normalize();

                // 2. Update Value Sprite (Center)
                if (node.sprite) {
                    const valPos = dir.clone().multiplyScalar(0.95); // Radius + slight padding
                    node.sprite.position.copy(valPos);
                }

                // 3. Update Balance Factor Sprite (Top-Right Offset)
                if (node.bfSprite) {
                    // We need a vector that is "up and right" relative to the view
                    // Approximate this by taking the 'dir' and adding a small World Y offset
                    // Then normalizing again to stay near surface, but shifting slightly
                    
                    // Simplest effective approach for 3D Label:
                    // Place it relative to the center sprite position
                    
                    // Get camera Up and Right vectors
                    const camUp = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);
                    const camRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    
                    // Base position (surface facing camera)
                    const basePos = dir.clone().multiplyScalar(1.0); 
                    
                    // Offset: Up and Right relative to camera view
                    basePos.addScaledVector(camUp, 0.6);
                    basePos.addScaledVector(camRight, 0.6);
                    
                    node.bfSprite.position.copy(basePos);
                }
            });

            // 4. Update Edges
            edges.forEach(line => {
                const positions = line.geometry.attributes.position.array;
                const start = line.userData.from.mesh.position;
                const end = line.userData.to.mesh.position;

                positions[0] = start.x;
                positions[1] = start.y;
                positions[2] = start.z;
                positions[3] = end.x;
                positions[4] = end.y;
                positions[5] = end.z;
                
                line.geometry.attributes.position.needsUpdate = true;
            });

            renderer.render(scene, camera);
        }


        // --- Interaction Logic ---
        function rebuildFromHistory(values) {
            treeRoot = null;
            nodes = [];
            values.forEach(val => { treeRoot = insert(treeRoot, val); });
            refreshTree();
            updateButtons();
        }

        window.addNode = function() {
            const input = document.getElementById('nodeValue');
            const val = parseInt(input.value);

            if (isNaN(val)) { log("Please enter a number", "alert"); return; }
            
            if(currentValues.includes(val)) {
                log(`Value ${val} already exists!`, "alert");
                input.value = '';
                return;
            }

            historyStack.push([...currentValues]);
            futureStack = []; 

            log(`Inserting ${val}...`);
            currentValues.push(val);
            
            treeRoot = insert(treeRoot, val);
            refreshTree();
            
            updateButtons();
            input.value = '';
            input.focus();
        }
        
        window.undo = function() {
            if (historyStack.length === 0) return;
            log("Undo", "action");
            futureStack.push([...currentValues]);
            currentValues = historyStack.pop();
            rebuildFromHistory(currentValues);
        }
        
        window.redo = function() {
            if (futureStack.length === 0) return;
            log("Redo", "action");
            historyStack.push([...currentValues]);
            currentValues = futureStack.pop();
            rebuildFromHistory(currentValues);
        }

        window.resetTree = function() {
            if (currentValues.length > 0) {
                historyStack.push([...currentValues]);
                futureStack = [];
            }
            treeRoot = null;
            nodes = [];
            currentValues = [];
            refreshTree();
            log("Tree reset complete", "action");
            updateButtons();
        }

        window.handleInput = function(e) {
            if(e.key === 'Enter') window.addNode();
        }

        // Init
        init();
        updateButtons();

    </script>
</body>
</html>