<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Queue Data Structure Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: white;
            pointer-events: none; /* Let clicks pass through to canvas if needed */
        }

        .control-panel {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #444;
            backdrop-filter: blur(5px);
            max-width: 300px;
        }

        button {
            transition: all 0.2s;
        }
        button:active { transform: scale(0.95); }

        /* 3D Labels that float over objects */
        .label {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
            border: 1px solid #fff;
            transition: opacity 0.2s;
            transform: translate(-50%, -100%); /* Center above point */
            display: none; /* Hidden by default */
        }

        .label.front { border-color: #4ade80; color: #4ade80; }
        .label.rear { border-color: #f472b6; color: #f472b6; }

        #stats {
            margin-top: 10px;
            font-size: 14px;
            color: #ccc;
        }
    </style>
</head>
<body>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- HTML Labels for Front/Rear -->
    <div id="label-front" class="label front">FRONT</div>
    <div id="label-rear" class="label rear">REAR</div>

    <!-- Control Panel -->
    <div id="ui-layer">
        <div class="control-panel">
            <h1 class="text-xl font-bold mb-2 text-white">Queue Structure</h1>
            <p class="text-sm text-gray-400 mb-4">FIFO: First In, First Out</p>
            
            <div class="flex gap-2 mb-4">
                <button onclick="enqueue()" class="flex-1 bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-4 rounded">
                    Enqueue (+)
                </button>
                <button onclick="dequeue()" class="flex-1 bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-4 rounded">
                    Dequeue (-)
                </button>
            </div>

            <div class="border-t border-gray-700 pt-2">
                <div id="stats">Size: 0</div>
                <div id="operation-log" class="text-xs text-yellow-400 mt-1 h-4 overflow-hidden">Waiting...</div>
            </div>
        </div>
    </div>

    <script>
        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.Fog(0x111111, 10, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 12, 15);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 2 - 0.1; // Prevent going under floor

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- Environment ---
        // Floor
        const floorGeometry = new THREE.PlaneGeometry(50, 50);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x222222, 
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Grid Helper
        const grid = new THREE.GridHelper(50, 50, 0x444444, 0x333333);
        scene.add(grid);

        // The "Service Point" (Where Front goes to exit)
        const portalGeo = new THREE.TorusGeometry(1.5, 0.2, 16, 100);
        const portalMat = new THREE.MeshBasicMaterial({ color: 0x4ade80 });
        const portal = new THREE.Mesh(portalGeo, portalMat);
        portal.position.set(-5, 1.5, 0);
        portal.rotation.y = Math.PI / 2;
        scene.add(portal);
        
        const portalLight = new THREE.PointLight(0x4ade80, 1, 10);
        portalLight.position.set(-5, 1.5, 0);
        scene.add(portalLight);

        // --- Queue Logic ---
        const queue = []; // The actual data structure
        const ITEM_SPACING = 2.5; // Distance between items
        const QUEUE_START_X = 0; // X position of the first item
        let itemCount = 0; // Used for unique IDs/Colors

        // HTML Label Elements
        const labelFront = document.getElementById('label-front');
        const labelRear = document.getElementById('label-rear');
        const statsDiv = document.getElementById('stats');
        const logDiv = document.getElementById('operation-log');

        // --- Functions ---

        function createQueueItem(id) {
            // Random Color Generator
            const color = new THREE.Color().setHSL(Math.random(), 0.7, 0.5);
            
            const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const material = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Initial spawn position (Enter from the right/back)
            // Calculate where the REAR is logically
            const rearIndex = queue.length;
            const targetX = QUEUE_START_X + (rearIndex * ITEM_SPACING);
            
            // Spawn slightly above and behind
            mesh.position.set(targetX + 5, 5, 0); 
            
            // Store target position for animation
            mesh.userData = {
                targetPos: new THREE.Vector3(targetX, 0.75, 0),
                velocity: new THREE.Vector3(0, 0, 0),
                id: id,
                isExiting: false
            };

            scene.add(mesh);
            return mesh;
        }

        function enqueue() {
            if (queue.length >= 10) {
                logDiv.innerText = "Queue Full (Overflow)!";
                return;
            }

            itemCount++;
            const item = createQueueItem(itemCount);
            queue.push(item);
            
            logDiv.innerText = `Enqueued Item #${itemCount}`;
            updateStats();
        }

        function dequeue() {
            if (queue.length === 0) {
                logDiv.innerText = "Queue Empty (Underflow)!";
                return;
            }

            // Remove from front (FIFO)
            const item = queue.shift(); 
            
            // Mark for exit animation
            item.userData.isExiting = true;
            item.userData.targetPos.set(-8, 0.75, 0); // Move through portal
            
            // Re-calculate targets for remaining items
            queue.forEach((mesh, index) => {
                const newX = QUEUE_START_X + (index * ITEM_SPACING);
                mesh.userData.targetPos.x = newX;
            });

            logDiv.innerText = `Dequeued Item #${item.userData.id}`;
            updateStats();

            // Cleanup removed item after delay
            setTimeout(() => {
                scene.remove(item);
                item.geometry.dispose();
                item.material.dispose();
            }, 1000);
        }

        function updateStats() {
            statsDiv.innerText = `Size: ${queue.length} | Front ID: ${queue.length > 0 ? queue[0].userData.id : '-'} | Rear ID: ${queue.length > 0 ? queue[queue.length-1].userData.id : '-'}`;
        }

        // --- Label Positioning ---
        function updateLabels() {
            if (queue.length === 0) {
                labelFront.style.display = 'none';
                labelRear.style.display = 'none';
                return;
            }

            // Helper to project 3D pos to 2D screen
            function updateLabelPos(mesh, labelElement, offsetY = 1.5) {
                const vector = new THREE.Vector3();
                vector.copy(mesh.position);
                vector.y += offsetY; // Floating above box

                // Project
                vector.project(camera);

                // Convert to CSS coords
                const x = (vector.x * .5 + .5) * window.innerWidth;
                const y = (-(vector.y * .5) - .5) * window.innerHeight + window.innerHeight;

                // Check if behind camera
                if (vector.z > 1) {
                    labelElement.style.display = 'none';
                } else {
                    labelElement.style.display = 'block';
                    labelElement.style.left = `${x}px`;
                    labelElement.style.top = `${y}px`;
                }
            }

            // Update Front Label
            updateLabelPos(queue[0], labelFront);

            // Update Rear Label
            updateLabelPos(queue[queue.length - 1], labelRear);
        }

        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // Animate Items
            const allItems = [...queue]; // Active queue
            
            // We also need to animate items that are currently exiting but not in the array anymore
            scene.traverse((obj) => {
                if (obj.isMesh && obj.userData.targetPos) {
                    // Smoothly interpolate to target
                    obj.position.lerp(obj.userData.targetPos, 5 * delta);

                    // Add a little bounce if entering
                    if (obj.position.distanceTo(obj.userData.targetPos) > 0.1 && obj.position.y > 0.8) {
                       // falling effect
                    }
                    
                    // Scale down if exiting
                    if (obj.userData.isExiting) {
                        obj.scale.lerp(new THREE.Vector3(0.1, 0.1, 0.1), 3 * delta);
                    }
                }
            });

            // Rotate Portal
            portal.rotation.z += delta;

            updateLabels();
            controls.update();
            renderer.render(scene, camera);
        }

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
        
        // Add initial item
        enqueue();

    </script>
</body>
</html>